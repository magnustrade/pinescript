// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// by © therkut
//@version=6
//# * Github: https://github.com/therkut/PineScript/tree/main/aifs
//# * Strategic: https://drive.google.com/file/d/11hIEjxSnyfGx1IyKce1SzKlHS1uUpzTq/view
indicator("SuperWaveTrend Ichimoku Theories Indicator", "AIFS", overlay= true, max_bars_back = 5000)
//-----------------------------------------------------------------------------{
//-----------------------------------------------------------------------------{
//1- SUPERTREND
//# * Author      : © KivancOzbilgic
//# * Use: Daily and 4H
//# * SuperTrend period: 
//# * for stock : 10,2/ 66,2/ 333,2/ 10,1/
//# * for Indx  : 10,2
////////////////////////
super_ok = input(true, title = '═══════════════ SuperTrend Settings ')

Periods = input.int(title='ATR Period', defval=10, group='SuperTrend')
st_src = input.source(hl2, title='Source', group='SuperTrend')
Multiplier = input.float(title='ATR Multiplier', step=0.1, defval=3.0, group='SuperTrend')
changeATR = input.bool(false, title='Change ATR Calculation Method ?', group='SuperTrend')
showsignals = input.bool(true, title='Show Buy/Sell Signals ?', group='SuperTrend')
showBuySignal = input.bool(false, title='Show Buy Signals', group='SuperTrend')
showSellSignal = input.bool(true, title='Show Sell Signals', group='SuperTrend')

// ATR Calculation
atr = changeATR ? ta.atr(Periods) : ta.sma(ta.tr, Periods)
up = st_src - Multiplier * atr
dn = st_src + Multiplier * atr
up1 = nz(up[1], up)
dn1 = nz(dn[1], dn)
up := close[1] > up1 ? math.max(up, up1) : up
dn := close[1] < dn1 ? math.min(dn, dn1) : dn

// Initialize trend variable
var float trend = na
trend := nz(trend[1], 1)
trend := trend == -1 and close > dn1 ? 1 : trend == 1 and close < up1 ? -1 : trend

// Plot SuperTrend
buySignal = trend == 1 and trend[1] == -1
sellSignal = trend == -1 and trend[1] == 1
plotshape(super_ok and showBuySignal and buySignal ? up : na, title='UpTrend Begins', location=location.absolute, style=shape.circle, size=size.tiny, color=color.green)
plotshape(super_ok and showSellSignal and sellSignal ? dn : na, title='DownTrend Begins', location=location.absolute, style=shape.circle, size=size.tiny, color=color.red)
plotshape(super_ok and showBuySignal and buySignal and showsignals ? up : na, title='Buy', text='Buy', location=location.absolute, style=shape.labelup, size=size.tiny, color=color.green, textcolor=color.white)
plotshape(super_ok and showSellSignal and sellSignal and showsignals ? dn : na, title='Sell', text='Sell', location=location.absolute, style=shape.labeldown, size=size.tiny, color=color.red, textcolor=color.white)

// Alerts
alertcondition(buySignal, title='SuperTrend Buy', message='SuperTrend Buy!')
alertcondition(sellSignal, title='SuperTrend Sell', message='SuperTrend Sell!')
alertcondition(trend != trend[1], title='SuperTrend Direction Change', message='SuperTrend has changed direction!')
//-----------------------------------------------------------------------------}


//-----------------------------------------------------------------------------{
//2- WAVETREND VT
//# * Author      : © LazyBear, modified by © therkut
////////////////////////
wave_ok = input(true, title = '═══════════════ WaveTrend Settings ')

group_wave = 'WaveTrend Settings'
chLength = input.int(10, 'Channel Length', minval=1, group=group_wave)
avgLength = input.int(21, 'Average Length', minval=1, group=group_wave)
sigLength = input.int(4, 'Signal Length', minval=1, group=group_wave)
upperBand1 = input.int(60, 'Upper Band Level-1', group=group_wave)
upperBand2 = input.int(53, 'Upper Band Level-2', group=group_wave)
lowerBand2 = input.int(-53, 'Lower Band Level-2', group=group_wave)
lowerBand1 = input.int(-60, 'Lower Band Level-1', group=group_wave)
crosses = input.string('Strong', 'Display Crosses', options=['Strong', 'All', 'None'], group=group_wave)
showWaveBuySignal = input.bool(true, title='Show WaveTrend Buy Signals', group=group_wave)
showWaveSellSignal = input.bool(false, title='Show WaveTrend Sell Signals', group=group_wave)

// WaveTrend Calculation
f_getWT(s, n1, n2, s1) =>
    esa = ta.ema(s, n1)
    d = ta.ema(math.abs(s - esa), n1)
    ci = (s - esa) / (0.015 * d)
    wt1 = ta.ema(ci, n2)
    wt2 = ta.sma(wt1, s1)
    [wt1, wt2]

[wt1, wt2] = f_getWT(hlc3, chLength, avgLength, sigLength)
lowerThreshold = math.avg(lowerBand1, lowerBand2)
upperThreshold = math.avg(upperBand1, upperBand2)

// Store crossover and crossunder results in global variables
crossover_wt = ta.crossover(wt1, wt2)
crossunder_wt = ta.crossunder(wt1, wt2)

// Plot WaveTrend
if wave_ok
    if crossover_wt and crosses != 'None'
        if wt1 < lowerThreshold and showWaveBuySignal
            label.new(bar_index, low, 'Buy', xloc.bar_index, yloc.price, color.green, label.style_label_up, color.white, size.normal)
        else if crosses != 'Strong' and wt1 < 0 and showWaveBuySignal
            label.new(bar_index, low, '', xloc.bar_index, yloc.price, color.green, label.style_label_up, color.white, size.tiny)

    if crossunder_wt and crosses != 'None'
        if wt1 > upperThreshold and showWaveSellSignal
            label.new(bar_index, high, 'Sell', xloc.bar_index, yloc.price, color.red, label.style_label_down, color.white, size.normal)
        else if crosses != 'Strong' and wt1 > 0 and showWaveSellSignal
            label.new(bar_index, high, '', xloc.bar_index, yloc.price, color.red, label.style_label_down, color.white, size.tiny)

// WaveTrend Alerts
alertcondition(wave_ok and crossover_wt and wt1 < lowerThreshold and showWaveBuySignal, title='WaveTrend Buy', message='WaveTrend Buy!')
alertcondition(wave_ok and crossunder_wt and wt1 > upperThreshold and showWaveSellSignal, title='WaveTrend Sell', message='WaveTrend Sell!')

//-----------------------------------------------------------------------------}


//-----------------------------------------------------------------------------{
//3- FIBONACCI RETRACEMENT
////////////////////////
fibonacci_ok = input(true, title = '═══════════════ Fibonacci Retracement Settings ')

showFibonacci = input.bool(true, 'Show Fibonacci Retracement', group='Fibonacci', inline='Fib')
extendRight = input.bool(true, title='Fibonacci Extend Right', group='Fibonacci', inline='Fib')
showFibData = input.bool(true, title='Fibonacci Show Data', group='Fibonacci', inline='Fib')
length = input.int(233, minval=8, title='Fibonacci Distance', group='Fibonacci')

fibHigh = ta.highest(length)
fibLow = ta.lowest(length)
fibColor = input.color(color.black, title='Fibonacci Color', group='Fibonacci')
highestBars = ta.highestbars(length)
lowestBars = ta.lowestbars(length)

fibLevel1 = input.int(618, title='Fib Level 1', group='Fibonacci', maxval=1618)
fibLevel2 = input.int(382, title='Fib Level 2', group='Fibonacci', maxval=1618)
fibLevel3 = input.int(786, title='Fib Level 3', group='Fibonacci', maxval=1618)

if fibonacci_ok and barstate.islast
    fib618 = lowestBars > highestBars ? fibHigh - (fibHigh - fibLow) * fibLevel1 / 1000 : fibLow + (fibHigh - fibLow) * fibLevel1 / 1000
    fib50 = lowestBars > highestBars ? fibHigh - (fibHigh - fibLow) * 500 / 1000 : fibLow + (fibHigh - fibLow) * 500 / 1000
    fib382 = lowestBars > highestBars ? fibHigh - (fibHigh - fibLow) * fibLevel2 / 1000 : fibLow + (fibHigh - fibLow) * fibLevel2 / 1000
    fib786 = lowestBars > highestBars ? fibHigh - (fibHigh - fibLow) * fibLevel3 / 1000 : fibLow + (fibHigh - fibLow) * fibLevel3 / 1000
    line.new(bar_index - highestBars, fibHigh, bar_index + 50, fibHigh, color=fibColor, width=1, extend=extendRight ? extend.right : extend.none)
    line.new(bar_index - lowestBars, fibLow, bar_index + 50, fibLow, color=fibColor, width=1, extend=extendRight ? extend.right : extend.none)
    line.new(bar_index + 10, fib382, bar_index + 50, fib382, color=fibColor, style=line.style_dashed, extend=extendRight ? extend.right : extend.none)
    line.new(bar_index + 10, fib50, bar_index + 50, fib50, color=fibColor, style=line.style_dashed, extend=extendRight ? extend.right : extend.none)
    line.new(bar_index + 10, fib618, bar_index + 50, fib618, color=fibColor, style=line.style_dashed, extend=extendRight ? extend.right : extend.none)
    line.new(bar_index + 10, fib786, bar_index + 50, fib786, color=fibColor, style=line.style_dashed, extend=extendRight ? extend.none : extend.none)
    if showFibData
        label.new(bar_index + 55, fibHigh, 'Top ( ' + str.tostring(math.round_to_mintick(fibHigh)) + ' )', color=color.gray, style=label.style_none, textcolor=color.black)
        label.new(bar_index + 55, fibLow, 'Bottom ( ' + str.tostring(math.round_to_mintick(fibLow)) + ' )', color=color.gray, style=label.style_none, textcolor=color.black)
        label.new(bar_index + 55, fib382, str.tostring(fibLevel2 / 1000) + ' ( ' + str.tostring(math.round_to_mintick(fib382)) + ' )', color=color.gray, style=label.style_none, textcolor=color.black)
        label.new(bar_index + 55, fib618, str.tostring(fibLevel1 / 1000) + ' ( ' + str.tostring(math.round_to_mintick(fib618)) + ' )', color=color.gray, style=label.style_none, textcolor=color.black)
        label.new(bar_index + 55, fib50, '% 50 ( ' + str.tostring(math.round_to_mintick(fib50)) + ' )', color=color.gray, style=label.style_none, textcolor=color.black)
        label.new(bar_index + 55, fib786, str.tostring(fibLevel3 / 1000) + ' ( ' + str.tostring(math.round_to_mintick(fib786)) + ' )', color=color.gray, style=label.style_none, textcolor=color.black)

//-----------------------------------------------------------------------------}


//-----------------------------------------------------------------------------{
//4- EMA 8/22/55
////////////////////////
ema_ok = input(false, title = '═══════════════ EMA Settings ')

ema1 = input.int(defval=8, title='EMA 1', group='MA', inline='E1')
ema1Show = input.bool(defval=true, group='MA', inline='E1', title='')

ema2 = input.int(defval=22, title='EMA 2', group='MA', inline='E2')
ema2Show = input.bool(defval=true, group='MA', inline='E2', title='')

ema3 = input.int(defval=55, title='EMA 3', group='MA', inline='E3')
ema3Show = input.bool(defval=true, group='MA', inline='E3', title='')

ema4 = input.int(defval=200, title='EMA 4', group='MA', inline='E4')
ema4Show = input.bool(defval=true, group='MA', inline='E4', title='')

// EMA Calculation
ema8 = ta.ema(close, ema1)
ema22 = ta.ema(close, ema2)
ema55 = ta.ema(close, ema3)
ema200x = ta.ema(close, ema4)

// Colors
color_ema8 = color.new(#36C5F0, 0)   // Blue
color_ema22 = color.new(#2EB67D, 0)  // Green
color_ema55 = color.new(#E01E5A, 0)  // Red
color_ema200 = color.new(#ECB22E, 0) // Yellow

// Plot EMAs
plot(ema_ok and ema1Show ? ema8 : na, color=color_ema8, linewidth=4)
plot(ema_ok and ema2Show ? ema22 : na, color=color_ema22, linewidth=1)
plot(ema_ok and ema3Show ? ema55 : na, color=color_ema55, linewidth=1)
plot(ema_ok and ema4Show ? ema200x : na, color=color_ema200, linewidth=4)

// Display EMA Values
if ema_ok and barstate.islast
    if ema4Show
        var label_id_200 = label.new(bar_index, na, "", xloc.bar_index, yloc.price, color_ema200)
        label.set_xy(label_id_200, bar_index, ema200x)
        label.set_text(label_id_200, "EMA 200: " + str.tostring(ema200x, format.mintick))
    if ema1Show or ema2Show or ema3Show
        var label_id = label.new(bar_index, na, "", xloc.bar_index, yloc.price, #2EB67D)
        ema_text = (ema3Show ? "EMA " + str.tostring(ema3) + ": " + str.tostring(math.round_to_mintick(ema55)) + "\n" : "") +
                   (ema2Show ? "EMA " + str.tostring(ema2) + ": " + str.tostring(math.round_to_mintick(ema22)) + "\n" : "") +
                   (ema1Show ? "EMA " + str.tostring(ema1) + ": " + str.tostring(math.round_to_mintick(ema8)) + "" : "")
        label.set_xy(label_id, bar_index + 5, ema8) 
        label.set_text(label_id, ema_text)
        label.set_tooltip(label_id, ema_text)

//-----------------------------------------------------------------------------}


//-----------------------------------------------------------------------------{
//5- BOLLINGER BANDS
////////////////////////
bbShow_ok = input.bool(false, title = '═══════════════ Bollinger Bands Settings')

lengthBB = input.int(20, minval=1, group='BB', inline='BB')
maType = input.string('SMA', 'Basis MA Type', options=['SMA', 'EMA', 'SMMA (RMA)', 'WMA', 'VWMA'], group='BB')
src = input(close, title='Source', group='BB')
mult = input.float(2.0, minval=0.001, maxval=50, title='StdDev', group='BB')

ma(source, lengthBB, _type) =>
    switch _type
        'SMA' => ta.sma(source, lengthBB)
        'EMA' => ta.ema(source, lengthBB)
        'SMMA (RMA)' => ta.rma(source, lengthBB)
        'WMA' => ta.wma(source, lengthBB)
        'VWMA' => ta.vwma(source, lengthBB)

basis = ma(src, lengthBB, maType)
dev = mult * ta.stdev(src, lengthBB)
upper = basis + dev
lower = basis - dev
offset = input.int(0, 'Offset', minval=-500, maxval=500, group='BB')
plot(bbShow_ok ? basis : na, 'Basis', color=#FF6D00, offset=offset)
p1 = plot(bbShow_ok ? upper : na, 'Upper', color=#2962FF, offset=offset)
p2 = plot(bbShow_ok ? lower : na, 'Lower', color=#2962FF, offset=offset)

fill(p1, p2, title='Background', color=bbShow_ok ? color.rgb(33, 150, 243, 90) : na)

//-----------------------------------------------------------------------------}

//-----------------------------------------------------------------------------{
//6- PARABOLIC SAR
////////////////////////
sarShow_ok = input.bool(false, title = '═══════════════ Parabolic SAR Settings')

start = input(0.02, group='P.SAR', inline='SAR')
increment = input(0.02, group='P.SAR')
maximum = input(0.2, 'Max Value', group='P.SAR')
out = ta.sar(start, increment, maximum)
plot(sarShow_ok ? out : na, 'ParabolicSAR', style=plot.style_cross, color=#2962FF)

//-----------------------------------------------------------------------------}


//-----------------------------------------------------------------------------{
//7- VOLUME BASED BARS
////////////////////////
vbcb_ok = input.bool(true, title = '═══════════════ Volume Based Coloured Bars Settings')
vbcb_length = input.int(21, 'Volume Based Bars Length', minval=1)
vbcb_avrg = ta.sma(volume, vbcb_length)

// Volume and price conditions
vbcb_vold1 = volume > vbcb_avrg * 1.5 and close < open
vbcb_vold2 = volume >= vbcb_avrg * 0.5 and volume <= vbcb_avrg * 1.5 and close < open
vbcb_vold3 = volume < vbcb_avrg * 0.5 and close < open
vbcb_volu1 = volume > vbcb_avrg * 1.5 and close > open
vbcb_volu2 = volume >= vbcb_avrg * 0.5 and volume <= vbcb_avrg * 1.5 and close > open
vbcb_volu3 = volume < vbcb_avrg * 0.5 and close > open

// Define colors
vbcb_cold1 = #800000
vbcb_cold2 = #FF0000
vbcb_cold3 = color.orange
vbcb_colu1 = #006400
vbcb_colu2 = color.lime
vbcb_colu3 = #7FFFD4

vbcb_VolColor = vbcb_vold1 ? vbcb_cold1 : vbcb_vold2 ? vbcb_cold2 : vbcb_vold3 ? vbcb_cold3 : vbcb_volu1 ? vbcb_colu1 : vbcb_volu2 ? vbcb_colu2 : vbcb_volu3 ? vbcb_colu3 : na

barcolor(vbcb_ok ? vbcb_VolColor : na, title='Volume Based Coloured Bars')

//-----------------------------------------------------------------------------}


//-----------------------------------------------------------------------------}
// 8- PRICE TABLE
// * Author      : © only_fibonacci, modified by © therkut
////////////////////////
infotbl_ok = input.bool(true, title = '═══════════════ Info Table Settings')
// Input options for various settings
textColor = input.color(defval = color.black, title = 'Text Color')

isMobile = input.bool(true, 'Is mobile?')
showTable = input.bool(false, 'Show Desktop Table?')
tablePosition = input.string(defval = 'Top Right', title = 'Table Position', options = ['Top Right', 'Bottom Right', 'Middle Right', 'Bottom Center', 'Bottom Left'])
tableSize = input.string(defval = 'Small', title = 'Table Size', options = ['Small', 'Large', 'Medium'])

// Determine the position of the table
position = switch tablePosition
    'Top Right' => position.top_right
    'Bottom Right' => position.bottom_right
    'Middle Right' => position.middle_right
    'Bottom Center' => position.bottom_center
    'Bottom Left' => position.bottom_left

sizeTbl = switch tableSize
    'Small' => size.small
    'Large' => size.large
    'Medium' => size.normal

var table mobileTable = table.new(position.bottom_right, 2, 9, border_width = 4, border_color = color.gray, frame_color = color.gray, frame_width = 4)
var table desktopTable = table.new(position, 6, 6, border_width = 4, border_color = color.gray, frame_color = color.gray, frame_width = 4)

// Input options for moving averages
emaPeriod1 = input.int(defval = 50, title = 'EMA 1', group = 'MA', inline = 'E1')
showEma1 = input.bool(defval = false, group = 'MA', inline = 'E1', title = '')
emaColor1 = input.color(defval = color.black, title = 'EMA1 COLOR', group = 'MA', inline = 'E6')

emaPeriod2 = input.int(defval = 100, title = 'EMA 2', group = 'MA', inline = 'E2')
showEma2 = input.bool(defval = false, group = 'MA', inline = 'E2', title = '')
emaColor2 = input.color(defval = color.black, title = 'EMA2 COLOR', group = 'MA', inline = 'E6')

emaPeriod3 = input.int(defval = 200, title = 'EMA 3', group = 'MA', inline = 'E3')
showEma3 = input.bool(defval = false, group = 'MA', inline = 'E3', title = '')
emaColor3 = input.color(defval = color.black, title = 'EMA3 COLOR', group = 'MA', inline = 'E6')

smaPeriod1 = input.int(defval = 50, title = 'SMA 1', group = 'MA', inline = 'E4')
showSma1 = input.bool(defval = false, group = 'MA', inline = 'E4', title = '')
smaColor1 = input.color(defval = color.black, title = 'SMA1 COLOR', group = 'MA', inline = 'E6')

smaPeriod2 = input.int(defval = 100, title = 'SMA 2', group = 'MA', inline = 'E4')
showSma2 = input.bool(defval = false, group = 'MA', inline = 'E4', title = '')
smaColor2 = input.color(defval = color.black, title = 'SMA2 COLOR', group = 'MA', inline = 'E6')

smaPeriod3 = input.int(defval = 200, title = 'SMA 3', group = 'MA', inline = 'E4')
showSma3 = input.bool(defval = false, group = 'MA', inline = 'E4', title = '')
smaColor3 = input.color(defval = color.black, title = 'SMA3 COLOR', group = 'MA', inline = 'E6')

// Calculate the moving averages
ema50 = ta.ema(close, emaPeriod1)
ema100 = ta.ema(close, emaPeriod2)
ema200 = ta.ema(close, emaPeriod3)
sma50 = ta.sma(close, smaPeriod1)
sma100 = ta.sma(close, smaPeriod2)
sma200 = ta.sma(close, smaPeriod3)

// Plot the moving averages
plot(showEma1 ? ema50 : na, color = emaColor1, title = 'EMA1')
plot(showEma2 ? ema100 : na, color = emaColor2, title = 'EMA2')
plot(showEma3 ? ema200 : na, color = emaColor3, title = 'EMA3')
plot(showSma1 ? sma50 : na, color = smaColor1, title = 'SMA1')
plot(showSma2 ? sma100 : na, color = smaColor2, title = 'SMA2')
plot(showSma3 ? sma200 : na, color = smaColor3, title = 'SMA3')

// Variables for table data
openPrice = open
closePrice = close
volumeData = volume
changePercent = ta.change(close) / close[1] * 100
rsi = ta.rsi(close, 14)

// Display desktop table
if barstate.islast and isMobile == false and showTable and infotbl_ok
    header1 = 'Open Price'
    header2 = 'Close Price'
    header3 = 'Change Percent'
    header4 = 'RSI'
    header5 = 'ATR'
    header6 = 'Volume'

    smaLabel1 = 'SMA' + str.tostring(smaPeriod1)
    smaLabel2 = 'SMA' + str.tostring(smaPeriod2)
    smaLabel3 = 'SMA' + str.tostring(smaPeriod3)
    emaLabel1 = 'EMA' + str.tostring(emaPeriod1)
    emaLabel2 = 'EMA' + str.tostring(emaPeriod2)
    emaLabel3 = 'EMA' + str.tostring(emaPeriod3)
    smaValue1 = str.tostring(math.round_to_mintick(sma50))
    smaValue2 = str.tostring(math.round_to_mintick(sma100))
    smaValue3 = str.tostring(math.round_to_mintick(sma200))
    emaValue1 = str.tostring(math.round_to_mintick(ema50))
    emaValue2 = str.tostring(math.round_to_mintick(ema100))
    emaValue3 = str.tostring(math.round_to_mintick(ema200))
    openValue = str.tostring(openPrice)
    closeValue = str.tostring(closePrice)
    changeValue = str.tostring(math.round_to_mintick(changePercent)) + ' %'
    rsiValue = str.tostring(math.round_to_mintick(rsi))
    atrValue = str.tostring(math.round_to_mintick(atr))
    volumeValue = str.tostring(volumeData)

    table.cell(desktopTable, 0, 0, bgcolor = color.black, text_color = color.white, text = header1, text_size = sizeTbl)
    table.cell(desktopTable, 1, 0, bgcolor = color.black, text_color = color.white, text = header2, text_size = sizeTbl)
    table.cell(desktopTable, 2, 0, bgcolor = color.black, text_color = color.white, text = header3, text_size = sizeTbl)
    table.cell(desktopTable, 3, 0, bgcolor = color.black, text_color = color.white, text = header4, text_size = sizeTbl)
    table.cell(desktopTable, 4, 0, bgcolor = color.black, text_color = color.white, text = header5, text_size = sizeTbl)
    table.cell(desktopTable, 5, 0, bgcolor = color.black, text_color = color.white, text = header6, text_size = sizeTbl)
    table.cell(desktopTable, 0, 1, bgcolor = color.black, text_color = color.white, text = openValue, text_size = sizeTbl)
    table.cell(desktopTable, 1, 1, bgcolor = color.black, text_color = color.white, text = closeValue, text_size = sizeTbl)
    table.cell(desktopTable, 2, 1, bgcolor = changePercent > 0 ? color.green : color.red, text_color = color.white, text = changeValue, text_size = sizeTbl)
    table.cell(desktopTable, 3, 1, bgcolor = rsi > 70 ? color.green : rsi < 30 ? color.red : color.teal, text_color = color.white, text = rsiValue, text_size = sizeTbl)
    table.cell(desktopTable, 4, 1, bgcolor = color.black, text_color = color.white, text = atrValue, text_size = sizeTbl)
    table.cell(desktopTable, 5, 1, bgcolor = color.black, text_color = color.white, text = volumeValue, text_size = sizeTbl)
    table.cell(desktopTable, 0, 2, bgcolor = color.gray, text_color = color.white, text = smaLabel1, text_size = sizeTbl)
    table.cell(desktopTable, 1, 2, bgcolor = color.gray, text_color = color.white, text = smaLabel2, text_size = sizeTbl)
    table.cell(desktopTable, 2, 2, bgcolor = color.gray, text_color = color.white, text = smaLabel3, text_size = sizeTbl)
    table.cell(desktopTable, 3, 2, bgcolor = color.gray, text_color = color.white, text = emaLabel1, text_size = sizeTbl)
    table.cell(desktopTable, 4, 2, bgcolor = color.gray, text_color = color.white, text = emaLabel2, text_size = sizeTbl)
    table.cell(desktopTable, 5, 2, bgcolor = color.gray, text_color = color.white, text = emaLabel3, text_size = sizeTbl)
    table.cell(desktopTable, 0, 3, bgcolor = sma50 > close ? color.red : color.green, text_color = color.white, text = smaValue1, text_size = sizeTbl)
    table.cell(desktopTable, 1, 3, bgcolor = sma100 > close ? color.red : color.green, text_color = color.white, text = smaValue2, text_size = sizeTbl)
    table.cell(desktopTable, 2, 3, bgcolor = sma200 > close ? color.red : color.green, text_color = color.white, text = smaValue3, text_size = sizeTbl)
    table.cell(desktopTable, 3, 3, bgcolor = ema50 > close ? color.red : color.green, text_color = color.white, text = emaValue1, text_size = sizeTbl)
    table.cell(desktopTable, 4, 3, bgcolor = ema100 > close ? color.red : color.green, text_color = color.white, text = emaValue2, text_size = sizeTbl)
    table.cell(desktopTable, 5, 3, bgcolor = ema200 > close ? color.red : color.green, text_color = color.white, text = emaValue3, text_size = sizeTbl)

// Display mobile table
if barstate.islast and isMobile == true and showTable == false and infotbl_ok
    header1 = 'Open Price'
    header2 = 'Close Price'
    header3 = 'Change Percent'
    header4 = 'RSI'
    header5 = 'ATR'
    header6 = 'Volume'
    emaLabel1 = 'EMA' + str.tostring(emaPeriod1)
    emaLabel2 = 'EMA' + str.tostring(emaPeriod2)
    emaLabel3 = 'EMA' + str.tostring(emaPeriod3)
    openValue = str.tostring(openPrice)
    closeValue = str.tostring(closePrice)
    changeValue = str.tostring(math.round_to_mintick(changePercent)) + ' %'
    rsiValue = str.tostring(math.round_to_mintick(rsi))
    atrValue = str.tostring(math.round_to_mintick(atr))
    volumeValue = str.tostring(volumeData)
    emaValue1 = str.tostring(math.round_to_mintick(ema50))
    emaValue2 = str.tostring(math.round_to_mintick(ema100))
    emaValue3 = str.tostring(math.round_to_mintick(ema200))

    table.cell(mobileTable, 0, 0, bgcolor = color.black, text_color = color.white, text = header1, text_size = sizeTbl)
    table.cell(mobileTable, 0, 1, bgcolor = color.black, text_color = color.white, text = header2, text_size = sizeTbl)
    table.cell(mobileTable, 0, 2, bgcolor = color.black, text_color = color.white, text = header3, text_size = sizeTbl)
    table.cell(mobileTable, 0, 3, bgcolor = color.black, text_color = color.white, text = header4, text_size = sizeTbl)
    table.cell(mobileTable, 0, 4, bgcolor = color.black, text_color = color.white, text = header5, text_size = sizeTbl)
    table.cell(mobileTable, 0, 5, bgcolor = color.black, text_color = color.white, text = header6, text_size = sizeTbl)
    // table.cell(mobileTable, 0, 6, bgcolor = color.black, text_color = color.white, text = emaLabel1, text_size = sizeTbl)
    // table.cell(mobileTable, 0, 7, bgcolor = color.black, text_color = color.white, text = emaLabel2, text_size = sizeTbl)
    // table.cell(mobileTable, 0, 8, bgcolor = color.black, text_color = color.white, text = emaLabel3, text_size = sizeTbl)

    table.cell(mobileTable, 1, 0, bgcolor = color.black, text_color = color.white, text = openValue, text_size = sizeTbl)
    table.cell(mobileTable, 1, 1, bgcolor = color.black, text_color = color.white, text = closeValue, text_size = sizeTbl)
    table.cell(mobileTable, 1, 2, bgcolor = color.black, text_color = color.white, text = changeValue, text_size = sizeTbl)
    table.cell(mobileTable, 1, 3, bgcolor = rsi > 70 ? color.green : rsi < 30 ? color.red : color.teal, text_color = color.white, text = rsiValue, text_size = sizeTbl)
    table.cell(mobileTable, 1, 4, bgcolor = color.black, text_color = color.white, text = atrValue, text_size = sizeTbl)
    table.cell(mobileTable, 1, 5, bgcolor = color.black, text_color = color.white, text = volumeValue, text_size = sizeTbl)

    // table.cell(mobileTable, 1, 6, bgcolor = ema50 > close ? color.red : color.green, text_color = color.white, text = emaValue1, text_size = sizeTbl)
    // table.cell(mobileTable, 1, 7, bgcolor = ema100 > close ? color.red : color.green, text_color = color.white, text = emaValue2, text_size = sizeTbl)
    // table.cell(mobileTable, 1, 8, bgcolor = ema200 > close ? color.red : color.green, text_color = color.white, text = emaValue3, text_size = sizeTbl)

//-----------------------------------------------------------------------------}


//-----------------------------------------------------------------------------}
// 9- ICHIMOKU THEORIES
// * Author      : © LuxAlgo
////////////////////////
ichimokuthrs_ok = input.bool(true, title = '═══════════════ Ichimoku Theories Settings')

//---------------------------------------------------------------------------------------------------------------------}
//CONSTANTS & STRINGS & INPUTS
//---------------------------------------------------------------------------------------------------------------------{
BULLISH_LEG = 1
BEARISH_LEG = 0

KIHON = 'KIHON SUCHI'
TAITO = 'TAITO SUCHI'

HIGHS = 'HIGHS'
LOWS = 'LOWS'
SWINGS = 'SWINGS'
TENKAN = 'TENKAN CROSS'
KIJUN = 'KIJUN CROSS'
KUMO = 'KUMO CHANGE'
WAVE = 'WAVES'

WAVE_I = 'WAVE I'
WAVE_V = 'WAVE V'
WAVE_N = 'WAVE N'
WAVE_P = 'WAVE P'
WAVE_Y = 'WAVE Y'
WAVE_W = 'WAVE W'

BULLISH = 'BULLISH'
BEARISH = 'BEARISH'

EN_SPACE = ' '
EM_SPACE = ' '
FOUR_PER_EM_SPACE = ' '
SIX_PER_EM_SPACE = ' '
HAIR_SPACE = ' '

GREEN = #089981
RED = #F23645

ICHIMOKU_GROUP = 'ICHIMOKU KINKŌ HYŌ'
TIME_GROUP = 'TIME THEORY'
WAVE_GROUP = 'WAVE THEORY'
PRICE_GROUP = 'PRICE THEORY'

showPivotMarksTooltip = 'Enable/Disable points on swing highs and swing lows.'
pivotLengthTooltip = 'Number of candles to confirm a swing high or swing low. A higher number detects larger swings.'
showIchimokuLinesTooltip = 'Enable/Disable the 5 Ichimoku lines: kijun sen, tenkan sen, senkou span A & B and chikou span.'
showIchimokuKumoTooltip = 'Enable/Disable the Kumo (cloud). The Kumo is formed by 2 lines: Senkou Span A and Senkou Span B.'
tenkanSenLengthTooltip = 'Number of candles for Tenkan Sen calculation.'
kinjuSenLengthTooltip = 'Number of candles for the Kijun Sen calculation.'
senkouSpanBLengthTooltip = 'Number of candles for Senkou Span B calculation.'
ichimokunOffsetTooltip = 'Number of candles for Chikou and Senkou Span calculation. Chikou Span is plotted in the past, Senkou Span A & B in the future.'
showTimeForecastTooltip = 'Enable/Disable time cycle forecast vertical lines. Disable for better performance.'
timePatternTooltip = 'Choose between two patterns: Kihon Suchi (basic numbers) or Taito Suchi (equal numbers).'
timeForecastAnchorTooltip = 'Number of time cycles in the past to anchor the time cycle forecast. The larger the number, the deeper in the past the anchor will be.'
timeCycleModeTooltip = 'Choose from 7 time cycle detection modes: Tenkan Sen cross, Kijun Sen cross, Kumo change between bullish & bearish, swing highs only, swing lows only, both swing highs & lows and wave detection.'
waveCyleTooltip = 'Choose which type of wave to detect from 6 different wave types when time cycle mode is set to WAVES.'
showTimeCyclesTooltip = 'Enable/Disable time cycle horizontal lines. Disable for better performance.'
maximumTimeCyclesTooltip = 'Maximum number of time cycles to display.'
basicWavesTooltip = 'Enable/Disable display of basic waves, all at once or one at a time. Disable for better performance.'
complexWavesTooltip = 'Enable/Disable complex wave display, all at once or one by one. Disable for better performance.'
overlappingWavesTooltip = 'Enable/Disable display of waves ending on the same swing point.'
maximumWavesTooltip = 'Maximum number of waves to display.'
basicTargetsTooltip = 'Enable/Disable horizontal price target lines. Disable for better performance.'
extendedTargetsTooltip = 'Enable/Disable extended price target horizontal lines. Disable for better performance.'

showPivotMarksInput = input.bool(true, 'Show Swing Highs & Lows', group = '', tooltip = showPivotMarksTooltip)
pivotLengthInput = input.int(10, 'Swing Length', group = '', tooltip = pivotLengthTooltip, minval = 1)

showIchimokuLinesInput = input.bool(false, 'Show Lines', group = ICHIMOKU_GROUP, tooltip = showIchimokuLinesTooltip)
showIchimokuKumoInput = input.bool(true, 'Show Kumo', group = ICHIMOKU_GROUP, tooltip = showIchimokuKumoTooltip)
tenkanSenLengthInput = input.int(9, 'Tenkan Sen Length', group = ICHIMOKU_GROUP, tooltip = tenkanSenLengthTooltip)
kinjuSenLengthInput = input.int(26, 'Kinjun Sen Length', group = ICHIMOKU_GROUP, tooltip = kinjuSenLengthTooltip)
senkouSpanBLengthInput = input.int(52, 'Senkou Span B Length', group = ICHIMOKU_GROUP, tooltip = senkouSpanBLengthTooltip)
ichimokuOffsetInput = input.int(26, 'Chikou & Senkou Offset', group = ICHIMOKU_GROUP, tooltip = ichimokunOffsetTooltip)

showTimeForecastInput = input.bool(true, 'Show Time Cycle Forecast', group = TIME_GROUP, tooltip = showTimeForecastTooltip)
timePatternInput = input.string(KIHON, 'Forecast Pattern', group = TIME_GROUP, tooltip = timePatternTooltip, options = [KIHON, TAITO])
timeForecastAnchorInput = input.int(1, 'Anchor forecast on last X time cycle', group = TIME_GROUP, tooltip = timeForecastAnchorTooltip, minval = 1)

timeCycleModeInput = input.string(SWINGS, 'Time Cycle Mode', group = TIME_GROUP, tooltip = timeCycleModeTooltip, options = [TENKAN, KIJUN, KUMO, HIGHS, LOWS, SWINGS, WAVE])
waveCyleInput = input.string(WAVE_I, 'Wave Cycle', group = TIME_GROUP, tooltip = waveCyleTooltip, options = [WAVE_I, WAVE_V, WAVE_N, WAVE_P, WAVE_Y, WAVE_W])
showTimeCyclesInput = input.bool(true, 'Show Time Cycles', group = TIME_GROUP, tooltip = showTimeCyclesTooltip)
maximumTimeCyclesInput = input.int(10, 'Show last X time cycles', group = TIME_GROUP, tooltip = maximumTimeCyclesTooltip, minval = 1)

showBasicWavesInput = input.bool(true, 'Basic Waves:' + EN_SPACE + EM_SPACE, group = WAVE_GROUP, tooltip = '', inline = 'basic waves')
showWaveIInput = input.bool(true, 'I', group = WAVE_GROUP, tooltip = '', inline = 'basic waves')
waveIColorInput = input.color(#e91e63, FOUR_PER_EM_SPACE, group = WAVE_GROUP, tooltip = '', inline = 'basic waves')
showWaveVInput = input.bool(false, 'V', group = WAVE_GROUP, tooltip = '', inline = 'basic waves')
waveVColorInput = input.color(color.yellow, '', group = WAVE_GROUP, tooltip = '', inline = 'basic waves')
showWaveNInput = input.bool(false, 'N', group = WAVE_GROUP, tooltip = '', inline = 'basic waves')
waveNColorInput = input.color(#5b9cf6, FOUR_PER_EM_SPACE, group = WAVE_GROUP, tooltip = basicWavesTooltip, inline = 'basic waves')

showComplexWavesInput = input.bool(false, 'Complex Waves:', group = WAVE_GROUP, tooltip = '', inline = 'complex waves')
showWavePInput = input.bool(true, 'P', group = WAVE_GROUP, tooltip = '', inline = 'complex waves')
wavePColorInput = input.color(color.aqua, '', group = WAVE_GROUP, tooltip = '', inline = 'complex waves')
showWaveYInput = input.bool(true, 'Y', group = WAVE_GROUP, tooltip = '', inline = 'complex waves')
waveYColorInput = input.color(#ff5d00, SIX_PER_EM_SPACE, group = WAVE_GROUP, tooltip = '', inline = 'complex waves')
showWaveWInput = input.bool(true, 'W', group = WAVE_GROUP, tooltip = '', inline = 'complex waves')
waveWColorInput = input.color(color.lime, HAIR_SPACE, group = WAVE_GROUP, tooltip = complexWavesTooltip, inline = 'complex waves')

overlappingWavesInput = input.bool(false, 'Overlapping Waves', group = WAVE_GROUP, tooltip = overlappingWavesTooltip)
maximumWavesInput = input.int(10, 'Show last X waves', group = WAVE_GROUP, tooltip = maximumWavesTooltip, minval = 1)

showBasicTargetsInput = input.bool(true, 'Basic Targets:' + EM_SPACE + EM_SPACE, group = PRICE_GROUP, tooltip = '', inline = 'basic targets')
showTargetVInput = input.bool(true, 'V' + EM_SPACE + EN_SPACE, group = PRICE_GROUP, tooltip = '', inline = 'basic targets')
showTargetEInput = input.bool(true, 'E' + EM_SPACE, group = PRICE_GROUP, tooltip = '', inline = 'basic targets')
showTargetNInput = input.bool(true, 'N' + EM_SPACE, group = PRICE_GROUP, tooltip = '', inline = 'basic targets')
showTargetNTInput = input.bool(true, 'NT', group = PRICE_GROUP, tooltip = basicTargetsTooltip, inline = 'basic targets')

showExtendedTargetsInput = input.bool(false, 'Extended Targets:', group = PRICE_GROUP, tooltip = '', inline = 'extended targets')
showTarget2EInput = input.bool(true, '2E' + EM_SPACE, group = PRICE_GROUP, tooltip = '', inline = 'extended targets')
showTarget3EInput = input.bool(true, '3E', group = PRICE_GROUP, tooltip = extendedTargetsTooltip, inline = 'extended targets')

//---------------------------------------------------------------------------------------------------------------------}
//DATA STRUCTURES & VARIABLES
//---------------------------------------------------------------------------------------------------------------------{
// @type                    Storage UDT for pivot points
// @field barTime           Time index of the privot point     
// @field barIndex          Bar index of the privot point
// @field priceLevel        Price level of the pivot point
// @field leg               Bullish or bearish bias (1 or 0)
type swingPoint
	int barTime
	int barIndex
	float priceLevel
	int leg

// @type                    Storage UDT for time cycles
// @field firstBarTime      Time index of the time cycle first bar 
// @field firstBarIndex     Bar index  of the time cycle first bar
// @field lastBarTime       Time index of the time cycle last bar
// @field lastBarIndex      Bar index  of the time cycle last bar
// @field cycleLine         Plotted line
// @field cycleLabel        Plotted label
type timeCycle
	int firstBarTime
	int firstBarIndex
	int lastBarTime
	int lastBarIndex
	line cycleLine
	label cycleLabel

// @type                    Storage UDT for waves
// @field points            chart.point array representing wave points
// @field tag               tag representing the type of wave
// @field bias              bullish of bearish bias as string
// @field waveLabel         plotted label
// @field line1             plotted line for P & Y waves 
// @field line2             plotted line for P & Y waves 
type wave
	array<chart.point> points
	string tag
	string bias
	label waveLabel
	line line1
	line line2

// @type                    Storage UDT for price targets
// @field targetLine        Plotted line
// @field targetLabel       Plotted label
type priceTarget
	line targetLine
	label targetLabel

// @variable                        storage array for `swingPoint` UDTs
var array<swingPoint> swingPoints = array.new<swingPoint>()
// @variable                        storage array for `timeCycle` UDTs
var array<timeCycle> timeCycles = array.new<timeCycle>()
// @variable                        storage array for time cycle forecast lines
var array<line> timeCyclesForecast = array.new<line>()
// @variable                        storage array for `wave` UDTs
var array<wave> waves = array.new<wave>()
// @variable                        storage array for `priceTarget` UDTs
var array<priceTarget> priceTargets = array.new<priceTarget>()

// @variable                        current leg bullish or bearish bias (1 or 0)
int currentLeg = na
// @variable                        true if there is a new pivot `pivotLengthInput` bars ago
bool newPivot = false
// @variable                        true if there is a new pivot low `pivotLengthInput` bars ago
bool pivotLow = false
// @variable                        true if there is a new pivot high `pivotLengthInput` bars ago
bool pivotHigh = false
// @variable                        tenkan sen values for plotting and rest of calculations
float tenkanSen = na
// @variable                        kijun sen values for plotting and rest of calculations
float kinjuSen = na
// @variable                        chikou span is the close price plotted X bars in the past
float chikouSpan = close
// @variable                        senkou span A for plotting and rest of calculations
float senkouSpanA = na
// @variable                        senkou span B for plotting and rest of calculations
float senkouSpanB = na
// @variable                        tracks the change in senkou span A >= senkou span B
bool kumoChange = false
// @variable                        color changes depending on `kumoChange` variable
color kumoColor = na
// @variable                        true if close crosses tenkan sen
bool tenkanSenCross = false
// @variable                        true if close crosses kinjun sen
bool kinjuSenCross = false
// @variable                        highest high on last X bars + volatility measure
float extremeHigh = na
// @variable                        lower low on last X bars - volatility measure
float extremeLow = na
// @variable                        true if current bar is a new extreme high
bool newExtremeHigh = false
// @variable                        true if current bar is a new extreme low
bool newExtremeLow = false
// @variable                        lower low since the start of the time cycles - volatility measure
var float lowest = na
// @variable                        bar index `pivotLengthInput` bars ago
int legIndex = bar_index[pivotLengthInput]
// @variable                        high `pivotLengthInput` bars ago
float legHigh = high[pivotLengthInput]
// @variable                        low `pivotLengthInput` bars ago
float legLow = low[pivotLengthInput]
// @variable                        time `pivotLengthInput` bars ago
int legTime = time[pivotLengthInput]
// @variable                        volatility measure to apply on `extremeHigh`, `extremeLow` and `lowest` calculations
float atr200 = ta.atr(200)

//---------------------------------------------------------------------------------------------------------------------}
//USER-DEFINED FUNCTIONS
//---------------------------------------------------------------------------------------------------------------------{
// @function            Get the value of the current leg, it can be 0 (bearish) or 1 (bullish)
// @returns             int
leg() =>
    var leg = 0
    newLegHigh = legHigh > ta.highest(pivotLengthInput)
    newLegLow = legLow < ta.lowest(pivotLengthInput)

    if newLegHigh
        leg := BEARISH_LEG
        leg
    else if newLegLow
        leg := BULLISH_LEG
        leg
    leg

// @function            Identify whether the current value is the start of a new leg (swing)
// @param leg           (int) Current leg value
// @returns             bool
startOfNewLeg(int leg) =>
    ta.change(leg) != 0

// @function            Identify whether the current level is the start of a new bearish leg (swing)
// @param leg           (int) Current leg value
// @returns             bool
startOfBearishLeg(int leg) =>
    ta.change(leg) == -1

// @function            Identify whether the current level is the start of a new bullish leg (swing)
// @param leg           (int) Current leg value
// @returns             bool
startOfBullishLeg(int leg) =>
    ta.change(leg) == +1

// @function            Average price on a price range
// @param length        (int) Number of bar to calculate the price range
// @returns             float
average(int length) =>
    math.round_to_mintick(0.5 * (ta.highest(length) + ta.lowest(length)))

// @function            Calculate highest high and lowest low +/- atr(200) over the `lastXBars` period
// @param lastXBars     (int) period for the calculations
// @returns             float tuple
extremesOnLastXBars(int lastXBars) =>
    [ta.highest(lastXBars) + atr200, ta.lowest(lastXBars) - atr200]

// @function            Parses swingPoint to chart.point
// @param point         swingPoint to parse
// @returns             chart.point ID
chartPoint(swingPoint point) =>
    chart.point.new(point.barTime, point.barIndex, point.priceLevel)

// @function            I wave detector
// @returns             wave ID
gatherWaveI() =>
    size = array.size(swingPoints)

    if size >= 2
        A = array.get(swingPoints, size - 2)
        B = array.get(swingPoints, size - 1)

        waveSize = B.barIndex - A.barIndex
        minimumWaveSize = waveSize >= 9

        if minimumWaveSize
            bias = B.leg == BULLISH_LEG ? BEARISH : BULLISH
            wave.new(array.from(chartPoint(A), chartPoint(B)), WAVE_I, bias)

// @function            V wave detector
// @returns             wave ID
gatherWaveV() =>
    size = array.size(swingPoints)

    if size >= 3
        A = array.get(swingPoints, size - 3)
        B = array.get(swingPoints, size - 2)
        C = array.get(swingPoints, size - 1)

        waveSize = C.barIndex - A.barIndex
        minimumWaveSize = waveSize >= 9

        threshold = math.abs(A.priceLevel - B.priceLevel) * 0.2
        isVWave = C.priceLevel >= A.priceLevel - threshold and C.priceLevel <= A.priceLevel + threshold

        if isVWave and minimumWaveSize
            bias = C.leg == BULLISH_LEG ? BEARISH : BULLISH
            wave.new(array.from(chartPoint(A), chartPoint(B), chartPoint(C)), WAVE_V, bias)

// @function            N wave detector
// @returns             wave ID
gatherWaveN() =>
    size = array.size(swingPoints)

    if size >= 4
        A = array.get(swingPoints, size - 4)
        B = array.get(swingPoints, size - 3)
        C = array.get(swingPoints, size - 2)
        D = array.get(swingPoints, size - 1)

        waveSize = D.barIndex - A.barIndex
        minimumWaveSize = waveSize >= 9

        threshold = math.abs(A.priceLevel - B.priceLevel) * 0.2
        isBullishWaveN = A.priceLevel < B.priceLevel and C.priceLevel > A.priceLevel + threshold and C.priceLevel < B.priceLevel - threshold and D.priceLevel > B.priceLevel + threshold
        isBearishWaveN = A.priceLevel > B.priceLevel and C.priceLevel < A.priceLevel - threshold and C.priceLevel > B.priceLevel + threshold and D.priceLevel < B.priceLevel - threshold

        isWaveN = isBullishWaveN or isBearishWaveN

        if isWaveN and minimumWaveSize
            bias = D.leg == BULLISH_LEG ? BEARISH : BULLISH
            wave.new(array.from(chartPoint(A), chartPoint(B), chartPoint(C), chartPoint(D)), WAVE_N, bias)

// @function            P wave detector
// @returns             wave ID
gatherWaveP() =>
    size = array.size(swingPoints)

    if size >= 4
        A = array.get(swingPoints, size - 4)
        B = array.get(swingPoints, size - 3)
        C = array.get(swingPoints, size - 2)
        D = array.get(swingPoints, size - 1)

        minimumDistance = math.min(math.abs(A.barIndex - C.barIndex), math.abs(B.barIndex - D.barIndex))
        threshold = 1.25 * minimumDistance
        goodShape = math.abs(A.barIndex - B.barIndex) <= threshold and math.abs(C.barIndex - D.barIndex) <= threshold

        waveSize = D.barIndex - A.barIndex
        minimumWaveSize = waveSize >= 9

        isBullishWaveP = math.max(A.priceLevel, B.priceLevel, C.priceLevel, D.priceLevel) == A.priceLevel and math.min(A.priceLevel, B.priceLevel, C.priceLevel, D.priceLevel) == B.priceLevel and C.priceLevel > D.priceLevel
        isBearishWaveP = math.min(A.priceLevel, B.priceLevel, C.priceLevel, D.priceLevel) == A.priceLevel and math.max(A.priceLevel, B.priceLevel, C.priceLevel, D.priceLevel) == B.priceLevel and C.priceLevel < D.priceLevel

        isWaveP = isBullishWaveP or isBearishWaveP

        if isWaveP and minimumWaveSize and goodShape
            bias = D.leg == BULLISH_LEG ? BEARISH : BULLISH
            wave.new(array.from(chartPoint(A), chartPoint(B), chartPoint(C), chartPoint(D)), WAVE_P, bias)

// @function            Y wave detector
// @returns             wave ID
gatherWaveY() =>
    size = array.size(swingPoints)

    if size >= 4
        A = array.get(swingPoints, size - 4)
        B = array.get(swingPoints, size - 3)
        C = array.get(swingPoints, size - 2)
        D = array.get(swingPoints, size - 1)

        minimumDistance = math.min(math.abs(A.barIndex - C.barIndex), math.abs(B.barIndex - D.barIndex))
        threshold = 1.25 * minimumDistance
        goodShape = math.abs(A.barIndex - B.barIndex) <= threshold and math.abs(C.barIndex - D.barIndex) <= threshold

        waveSize = D.barIndex - A.barIndex
        minimumWaveSize = waveSize >= 9

        isBullishWaveY = math.max(A.priceLevel, B.priceLevel, C.priceLevel, D.priceLevel) == C.priceLevel and math.min(A.priceLevel, B.priceLevel, C.priceLevel, D.priceLevel) == D.priceLevel and A.priceLevel > B.priceLevel
        isBearishWaveY = math.min(A.priceLevel, B.priceLevel, C.priceLevel, D.priceLevel) == C.priceLevel and math.max(A.priceLevel, B.priceLevel, C.priceLevel, D.priceLevel) == D.priceLevel and A.priceLevel < B.priceLevel

        isWaveY = isBullishWaveY or isBearishWaveY

        if isWaveY and minimumWaveSize and goodShape
            bias = D.leg == BULLISH_LEG ? BEARISH : BULLISH
            wave.new(array.from(chartPoint(A), chartPoint(B), chartPoint(C), chartPoint(D)), WAVE_Y, bias)

// @function            W wave detector
// @returns             wave ID
gatherWaveW() =>
    size = array.size(swingPoints)

    if size >= 5
        A = array.get(swingPoints, size - 5)
        B = array.get(swingPoints, size - 4)
        C = array.get(swingPoints, size - 3)
        D = array.get(swingPoints, size - 2)
        E = array.get(swingPoints, size - 1)

        waveSize = E.barIndex - A.barIndex
        minimumWaveSize = waveSize >= 9

        threshold = math.abs(A.priceLevel - B.priceLevel) * 0.2
        isBullishWaveW = C.priceLevel <= A.priceLevel - threshold and C.priceLevel >= B.priceLevel + threshold and E.priceLevel >= A.priceLevel - threshold and E.priceLevel <= A.priceLevel + threshold and D.priceLevel >= B.priceLevel - threshold and D.priceLevel <= B.priceLevel + threshold
        isBearishWaveW = C.priceLevel >= A.priceLevel + threshold and C.priceLevel <= B.priceLevel - threshold and E.priceLevel >= B.priceLevel - threshold and E.priceLevel <= B.priceLevel + threshold and D.priceLevel >= A.priceLevel - threshold and D.priceLevel <= A.priceLevel + threshold

        isWaveW = isBullishWaveW or isBearishWaveW

        if isWaveW and minimumWaveSize
            bias = E.leg == BULLISH_LEG ? BEARISH : BULLISH
            wave.new(array.from(chartPoint(A), chartPoint(B), chartPoint(C), chartPoint(D), chartPoint(E)), WAVE_W, bias)

// @function            Storage a new wave
// @param newWave       wave to store
// @returns             void
addWave(wave newWave) =>
    if waves.size() >= maximumWavesInput
        w_ave = waves.shift()
        label.delete(w_ave.waveLabel)
        line.delete(w_ave.line1)
        line.delete(w_ave.line2)
    array.push(waves, newWave)

// @function            Detects and stores new waves
// @returns             void
gatherWaves() =>
    wave waveI = na
    wave waveV = na
    wave waveN = na
    wave waveP = na
    wave waveY = na
    wave waveW = na

    if showBasicWavesInput and showWaveIInput
        waveI := gatherWaveI()
        waveI
    if showBasicWavesInput and showWaveVInput
        waveV := gatherWaveV()
        waveV
    if showBasicWavesInput and showWaveNInput
        waveN := gatherWaveN()
        waveN
    if showComplexWavesInput and showWavePInput
        waveP := gatherWaveP()
        waveP
    if showComplexWavesInput and showWaveYInput
        waveY := gatherWaveY()
        waveY
    if showComplexWavesInput and showWaveWInput
        waveW := gatherWaveW()
        waveW

    if overlappingWavesInput
        if not na(waveI)
            addWave(waveI)
        if not na(waveV)
            addWave(waveV)
        if not na(waveN)
            addWave(waveN)
        if not na(waveP)
            addWave(waveP)
        if not na(waveY)
            addWave(waveY)
        if not na(waveW)
            addWave(waveW)
    else
        wave w_ave = na
        if not na(waveN)
            w_ave := waveN
            w_ave
        else if not na(waveW)
            w_ave := waveW
            w_ave
        else if not na(waveP)
            w_ave := waveP
            w_ave
        else if not na(waveY)
            w_ave := waveY
            w_ave
        else if not na(waveV)
            w_ave := waveV
            w_ave
        else if not na(waveI)
            w_ave := waveI
            w_ave

        if not na(w_ave)
            addWave(w_ave)

// @function            Helper function to choose the right wave color
// @param typeOfWave    (string) type of wave
// @returns             color
colorSelection(string typeOfWave) =>
    switch typeOfWave
        WAVE_I => waveIColorInput
        WAVE_V => waveVColorInput
        WAVE_N => waveNColorInput
        WAVE_P => wavePColorInput
        WAVE_Y => waveYColorInput
        WAVE_W => waveWColorInput

// @function            Draws stored waves
// @returns             void
plotWaves() =>
    for eachPolyline in polyline.all
        polyline.delete(eachPolyline)

    for [index, eachWave] in waves
        label.delete(eachWave.waveLabel)

        // we draw P & Y waves with 2 lines
        if eachWave.tag == WAVE_P or eachWave.tag == WAVE_Y
            eachWave.line1.delete()
            eachWave.line2.delete()
            eachWave.line1 := line.new(eachWave.points.get(0), eachWave.points.get(2), xloc.bar_time, color = colorSelection(eachWave.tag), style = line.style_solid, width = 2)
            eachWave.line2 := line.new(eachWave.points.get(1), eachWave.points.get(3), xloc.bar_time, color = colorSelection(eachWave.tag), style = line.style_solid, width = 2)
            eachWave.line2
        else // we draw the rest of waves with polyline
            polyline.new(eachWave.points, false, false, xloc.bar_time, colorSelection(eachWave.tag), line_style = line.style_solid, line_width = 2)

        overlappingLabel = index > 0 ? eachWave.points.last().time == waves.get(index - 1).points.last().time : false
        style = eachWave.bias == BULLISH ? label.style_label_down : label.style_label_up

        if overlappingLabel
            eachWave.waveLabel := waves.get(index - 1).waveLabel
            eachWave.waveLabel.set_text(eachWave.waveLabel.get_text() + '\n' + eachWave.tag)
            eachWave.waveLabel.set_textcolor(colorSelection(eachWave.tag))
        else
            eachWave.waveLabel := label.new(eachWave.points.last(), eachWave.tag, xloc.bar_time, color = color(na), style = style, textcolor = colorSelection(eachWave.tag))
            label.delete(na)

// @function            Draws a price target with a line and a label
// @param barIndex      (int) starting bar index for line
// @param priceLevel    (float) price level for line and label
// @param tag           (string) text to display in label
// @returns             void
drawPriceTarget(int barIndex, float priceLevel, string tag) =>
    array.push(priceTargets, priceTarget.new(line.new(barIndex, priceLevel, last_bar_index + ichimokuOffsetInput, priceLevel, color = chart.fg_color, style = line.style_dotted), label.new(last_bar_index + ichimokuOffsetInput, priceLevel, tag + ' (' + str.tostring(priceLevel) + ')', color = color(na), textcolor = chart.fg_color, style = label.style_label_left)))

// @function            Detects developing N waves and draws price targets
// @returns             void
priceTheoryTargets() =>
    size = array.size(swingPoints)

    if size >= 3
        A = array.get(swingPoints, size - 3)
        B = array.get(swingPoints, size - 2)
        C = array.get(swingPoints, size - 1)

        waveSize = C.barIndex - A.barIndex
        minimumWaveSize = waveSize >= 9

        threshold = math.abs(A.priceLevel - B.priceLevel) * 0.2
        isDevelopingBullishWaveN = A.priceLevel < B.priceLevel and C.priceLevel > A.priceLevel + threshold and C.priceLevel < B.priceLevel - threshold
        isDevelopingBearishWaveN = A.priceLevel > B.priceLevel and C.priceLevel < A.priceLevel - threshold and C.priceLevel > B.priceLevel + threshold

        isDevelopingWaveN = isDevelopingBullishWaveN or isDevelopingBearishWaveN

        calculationV = .0
        calculationE = .0
        calculationN = .0
        calculationNT = .0
        calculation2E = .0
        calculation3E = .0

        if isDevelopingWaveN and minimumWaveSize

            for eachPriceTarget in priceTargets
                line.delete(eachPriceTarget.targetLine)
                label.delete(eachPriceTarget.targetLabel)
            array.clear(priceTargets)

            if isDevelopingBullishWaveN
                calculationV := B.priceLevel + B.priceLevel - C.priceLevel
                calculationE := B.priceLevel + B.priceLevel - A.priceLevel
                calculationN := C.priceLevel + B.priceLevel - A.priceLevel
                calculationNT := C.priceLevel + C.priceLevel - A.priceLevel
                calculation2E := B.priceLevel + 2 * (B.priceLevel - A.priceLevel)
                calculation3E := B.priceLevel + 3 * (B.priceLevel - A.priceLevel)
                calculation3E

            if isDevelopingBearishWaveN
                calculationV := B.priceLevel - (C.priceLevel - B.priceLevel)
                calculationE := B.priceLevel - (A.priceLevel - B.priceLevel)
                calculationN := C.priceLevel - (A.priceLevel - B.priceLevel)
                calculationNT := C.priceLevel - (A.priceLevel - C.priceLevel)
                calculation2E := B.priceLevel - 2 * (A.priceLevel - B.priceLevel)
                calculation3E := B.priceLevel - 3 * (A.priceLevel - B.priceLevel)
                calculation3E

            if showBasicTargetsInput and showTargetVInput
                drawPriceTarget(C.barIndex, calculationV, 'V')
            if showBasicTargetsInput and showTargetEInput
                drawPriceTarget(C.barIndex, calculationE, 'E')
            if showBasicTargetsInput and showTargetNInput
                drawPriceTarget(C.barIndex, calculationN, 'N')
            if showBasicTargetsInput and showTargetNTInput
                drawPriceTarget(C.barIndex, calculationNT, 'NT')
            if showExtendedTargetsInput and showTarget2EInput
                drawPriceTarget(C.barIndex, calculation2E, '2E')
            if showExtendedTargetsInput and showTarget3EInput
                drawPriceTarget(C.barIndex, calculation3E, '3E')

// @function            Update each price target line and label to draw always with an `ichimokuOffsetInput` offset
// @returns             void
updatePriceTargets() =>
    for eachPriceTarget in priceTargets
        line.set_x2(eachPriceTarget.targetLine, last_bar_index + ichimokuOffsetInput)
        label.set_x(eachPriceTarget.targetLabel, last_bar_index + ichimokuOffsetInput)

// @function            Helper function to update last time cycle values before store the new one
// @param cycle         (timeCycle) new detected cycle
// @returns             int
updateLastTimeCycle(timeCycle cycle) =>
    size = array.size(timeCycles)
    if size > 0
        c_ycle = array.last(timeCycles)
        c_ycle.lastBarIndex := cycle.firstBarIndex
        c_ycle.lastBarTime := cycle.firstBarTime
        c_ycle.lastBarTime

// @function            Helper function to store a new time cycle
// @param cycle         (timeCycle) time cycle to store
// @returns             void
addTimeCycle(timeCycle cycle) =>
    updateLastTimeCycle(cycle)
    size = array.size(timeCycles)

    if size >= maximumTimeCyclesInput + 1
        c_ycle = array.shift(timeCycles)
        line.delete(c_ycle.cycleLine)
        label.delete(c_ycle.cycleLabel)
    array.push(timeCycles, cycle)

// @function            Helper function to parse `wave` to `timeCycle`
// @returns             void
parseWavesToTimeCycles() =>
    for eachCycle in timeCycles
        eachCycle.cycleLabel.delete()
        eachCycle.cycleLine.delete()
    timeCycles.clear()

    for index = waves.size() - 1 to 0 by 1
        if timeCycles.size() >= maximumTimeCyclesInput
            break
        if waves.get(index).tag == waveCyleInput
            timeCycles.unshift(timeCycle.new(waves.get(index).points.first().time, waves.get(index).points.first().index, waves.get(index).points.last().time, waves.get(index).points.last().index))

// @function            Detect and store time cycles
// @returns             void
gatherTimeCycles() =>
    timeCycle newCycle = switch timeCycleModeInput
        HIGHS => pivotHigh ? timeCycle.new(legTime, legIndex) : na
        LOWS => pivotLow ? timeCycle.new(legTime, legIndex) : na
        SWINGS => newPivot ? timeCycle.new(legTime, legIndex) : na
        TENKAN => tenkanSenCross ? timeCycle.new(time, bar_index) : na
        KIJUN => kinjuSenCross ? timeCycle.new(time, bar_index) : na
        KUMO => kumoChange ? timeCycle.new(time, bar_index) : na
        WAVE => na

    if not na(newCycle)
        addTimeCycle(newCycle)
    else if timeCycleModeInput == WAVE and waves.size() > 0
        parseWavesToTimeCycles()

// @function            Draws each time cycle with a line and a label
// @returns             last label ID
plotTimeCycles() =>
    size = array.size(timeCycles)

    if size > 1
        priceLevel = lowest

        for [index, eachCycle] in timeCycles
            line.delete(eachCycle.cycleLine)
            label.delete(eachCycle.cycleLabel)

            tagPosition = math.max(1, math.round(0.5 * (eachCycle.lastBarTime - eachCycle.firstBarTime)))

            if index == array.size(timeCycles) - 1 and timeCycleModeInput != WAVE
                break

            if timeCycleModeInput == WAVE and index > 0
                if eachCycle.firstBarIndex < timeCycles.get(index - 1).lastBarIndex
                    priceLevel := priceLevel - atr200
                    priceLevel

            eachCycle.cycleLine := line.new(eachCycle.firstBarTime, priceLevel, eachCycle.lastBarTime, priceLevel, xloc.bar_time, color = chart.fg_color, style = line.style_arrow_right)
            eachCycle.cycleLabel := label.new(eachCycle.firstBarTime + tagPosition, priceLevel, str.tostring(eachCycle.lastBarIndex - eachCycle.firstBarIndex), xloc.bar_time, color = color(na), style = label.style_none, textcolor = chart.fg_color)
            eachCycle.cycleLabel

// @function            Draws time cycle forecast vertical lines
// @returns             void
plotTimeCyclesForecast() =>
    lastArrayIndex = array.size(timeCycles) - (timeCycleModeInput == WAVE ? 0 : 1)

    if lastArrayIndex >= timeForecastAnchorInput
        cycle = array.get(timeCycles, lastArrayIndex - timeForecastAnchorInput)
        taitoCycle = cycle.lastBarIndex - cycle.firstBarIndex
        forecastAnchor = cycle.lastBarIndex
        array<int> indexes = switch timePatternInput
            KIHON => array.from(9, 17, 26, 33, 42, 51, 65, 76, 129, 172, 200, 257)
            TAITO => array.from(taitoCycle, 2 * taitoCycle, 3 * taitoCycle, 4 * taitoCycle, 5 * taitoCycle, 6 * taitoCycle, 7 * taitoCycle, 8 * taitoCycle, 9 * taitoCycle)

        for eachLine in timeCyclesForecast
            line.delete(eachLine)
        array.clear(timeCyclesForecast)

        array.push(timeCyclesForecast, line.new(forecastAnchor, extremeHigh, forecastAnchor, extremeLow, color = chart.fg_color, style = line.style_solid))

        for index in indexes

            if forecastAnchor + index > last_bar_index + 500
                break
            array.push(timeCyclesForecast, line.new(forecastAnchor + index, extremeHigh, forecastAnchor + index, extremeLow, color = chart.fg_color, style = line.style_dotted))

// @function            Update each time cycle forecast line extremes
// @returns             void
updateTimeCyclesForecast() =>
    if newExtremeHigh or newExtremeLow
        for eachTimeCycle in timeCyclesForecast
            if newExtremeHigh
                eachTimeCycle.set_y1(extremeHigh)
            if newExtremeLow
                eachTimeCycle.set_y2(extremeLow)

//---------------------------------------------------------------------------------------------------------------------}
//MUTABLE VARIABLES & EXECUTION
//---------------------------------------------------------------------------------------------------------------------{
currentLeg := leg()
newPivot := startOfNewLeg(currentLeg)
pivotLow := startOfBullishLeg(currentLeg)
pivotHigh := startOfBearishLeg(currentLeg)

tenkanSen := average(tenkanSenLengthInput)
kinjuSen := average(kinjuSenLengthInput)
senkouSpanA := 0.5 * (tenkanSen + kinjuSen)
senkouSpanB := average(senkouSpanBLengthInput)
kumoChange := ta.change(senkouSpanA >= senkouSpanB)
kumoColor := senkouSpanA >= senkouSpanB ? color.new(GREEN, 80) : color.new(RED, 80)

tenkanSenCross := ta.cross(close, tenkanSen)
kinjuSenCross := ta.cross(close, kinjuSen)

[e_xtremeHigh, e_xtremeLow] = extremesOnLastXBars(200)
extremeHigh := e_xtremeHigh
extremeLow := e_xtremeLow
newExtremeHigh := ta.change(extremeHigh) != 0
newExtremeLow := ta.change(extremeLow) != 0

if array.size(timeCycles) > 0 and bar_index > 200
    lowest := ta.lowest(bar_index - array.first(timeCycles).firstBarIndex) - atr200
    lowest

// @variable            true if current candle is a new time cycle
bool newTimeCycle = switch timeCycleModeInput
    HIGHS => pivotHigh
    LOWS => pivotLow
    SWINGS => newPivot
    TENKAN => tenkanSenCross
    KIJUN => kinjuSenCross
    KUMO => kumoChange
    WAVE => newPivot

// we execute the logic only once per bar close
if barstate.isconfirmed
    // if there is a new swing point execute the logic
    if newPivot
        priceLevel = legHigh
        legBias = BEARISH_LEG

        // if the new swing point is a pivot low change the values
        if pivotLow
            priceLevel := legLow
            legBias := BULLISH_LEG
            legBias

        // we store the new swing point
        array.push(swingPoints, swingPoint.new(legTime, legIndex, priceLevel, legBias))

        // we gather new waves
        gatherWaves()

        if showBasicWavesInput or showComplexWavesInput
            // we plot all stored waves
            plotWaves()

        if showBasicTargetsInput or showExtendedTargetsInput
            // we detect and plot price targets
            priceTheoryTargets()

    if priceTargets.size() > 0
        // if there are price targets, we update them
        updatePriceTargets()

    if newTimeCycle
        // at each new time cycle we detect and store the new cycle
        gatherTimeCycles()

        if showTimeCyclesInput
            // we plot all time cycles
            plotTimeCycles()

        if showTimeForecastInput
            // we plot all time cycles forecast
            plotTimeCyclesForecast()

    else
        if showTimeForecastInput
            // we update time cycles forecast vertical lines
            updateTimeCyclesForecast()

// plotting circle marks on swing highs and lows
plotshape(showPivotMarksInput ? pivotLow : false, 'Swing High', shape.circle, location.belowbar, GREEN, -pivotLengthInput)
plotshape(showPivotMarksInput ? pivotHigh : false, 'Swing Low', shape.circle, location.abovebar, RED, -pivotLengthInput)

// plotting basic Ichimoku lines and kumo
plot(showIchimokuLinesInput ? tenkanSen : na, 'TenkanSen', color = RED)
plot(showIchimokuLinesInput ? kinjuSen : na, 'KinjuSen', color = color.blue)
plot(showIchimokuLinesInput ? chikouSpan : na, 'ChikouSpan', offset = -ichimokuOffsetInput, color = color.new(#787b86, 50))

kumoFast = plot(showIchimokuKumoInput ? senkouSpanA : na, 'SenkouSpanA', kumoColor, offset = ichimokuOffsetInput)
kumoSlow = plot(showIchimokuKumoInput ? senkouSpanB : na, 'SenkouSpanB', kumoColor, offset = ichimokuOffsetInput)

fill(kumoFast, kumoSlow, color = kumoColor, title = 'Kumo')

//-----------------------------------------------------------------------------}


//-----------------------------------------------------------------------------}
// 9- AR FORECAST
// * Author      : © Steversteves
////////////////////////
arforecast_ok = input.bool(false, title = '═══════════════ Forecast Scatterplot Settings')


import Steversteves/SPTS_StatsPakLib/1 as spts

//@peacefulLizard50262
flush(source) =>
    if source.size() > 0
        for i = source.size() - 1 to 0 by 1
            source.get(i).delete()
            source.remove(i)

t1 = 'This will plot a line from the first Result to the last Result for the forecast length'
t2 = 'Showing results and variances will plot both the results (blue) and the standard errors based on the variance in the dataset. Only plotting reuslts will only plot the most likely outcome without the variance.'
t3 = 'This will omit the need for you to identify the lookback length yourself and will autofind the best lookback period'
// Inputs 
arsrc = input.source(close, 'Forecast Source')
train1 = input.int(150, 'Train Time')
len = input.int(14, 'Forecast Length')
typ = input.string('Scatter Plot', 'Scatter Plot Type', ['Line Plot', 'Scatter Plot'])
show_stats = input.bool(false, 'Show Model Statistics')
line_bf = input.bool(true, 'Show Trendline', tooltip = t1)
show_others = input.string('Show Results and Variances', 'Show Results/Variance', ['Show Results and Variances', 'Show Results Only'], tooltip = t2)
autolen = input.bool(true, 'Use Auto lookback based on strongest trend', tooltip = t3)
onlytrend = input.bool(true, 'Only Show Trendline')
// Arrays 
results = array.new_float()
ucl = array.new_float()
lcl = array.new_float()

// Find Trend
trend_finder(len) =>
    ta.correlation(close, time, len)

t50 = trend_finder(50)
t100 = trend_finder(100)
t150 = trend_finder(150)
t200 = trend_finder(200)
t250 = trend_finder(250)
t300 = trend_finder(300)
t350 = trend_finder(350)
t400 = trend_finder(400)
t450 = trend_finder(450)
t500 = trend_finder(500)
t550 = trend_finder(550)
t600 = trend_finder(600)
t650 = trend_finder(650)
t700 = trend_finder(700)
strongest_trend = math.max(t50, t100, t150, t200, t250, t300, t350, t400, t450, t500, t550, t600, t650, t700)
int find_trend = strongest_trend == t50 ? 50 : strongest_trend == t100 ? 100 : strongest_trend == t150 ? 150 : strongest_trend == t200 ? 200 : strongest_trend == t250 ? 250 : strongest_trend == t300 ? 300 : strongest_trend == t350 ? 350 : strongest_trend == t400 ? 400 : strongest_trend == t450 ? 450 : strongest_trend == t500 ? 500 : strongest_trend == t550 ? 550 : strongest_trend == t600 ? 600 : strongest_trend == t650 ? 650 : strongest_trend == t700 ? 700 : 100

int train = 0
if autolen
    train := find_trend
    train
else
    train := train1
    train


// Forecast 
[forecast_result, b, c] = spts.f_forecast(arsrc, arsrc[1], train, len, results, ucl, lcl)

// Model Statistics 
cor = ta.correlation(arsrc, arsrc[len], train)
r2 = math.pow(cor, 2)
max_val = array.max(ucl)
min_val = array.min(lcl)

f_primary_labels(id) =>
    label.new(bar_index + id, array.get(results, id), text = '', color = color.blue, style = label.style_circle, size = size.tiny)
f_secondary_labels(id) =>
    label.new(bar_index + id, array.get(ucl, id), text = '', color = color.lime, style = label.style_circle, size = size.tiny)
f_secondary_labels2(id) =>
    label.new(bar_index + id, array.get(lcl, id), text = '', color = color.red, style = label.style_circle, size = size.tiny)
f_primary_line(id) =>
    line.new(bar_index + id, y1 = array.get(results, id), x2 = bar_index + 1 + id, y2 = array.get(results, id), color = color.blue, width = 3)
f_secondary_line(id) =>
    line.new(bar_index + id, y1 = array.get(ucl, id), x2 = bar_index + 1 + id, y2 = array.get(ucl, id), color = color.lime, width = 3)
f_secondary_line2(id) =>
    line.new(bar_index + id, y1 = array.get(lcl, id), x2 = bar_index + 1 + id, y2 = array.get(lcl, id), color = color.red, width = 3)

var label1_ar = array.new<label>()
var label2_ar = array.new<label>()
var label3_ar = array.new<label>()
var line1_ar = array.new<line>()
var line2_ar = array.new<line>()
var line3_ar = array.new<line>()

flush(label1_ar)
flush(label2_ar)
flush(label3_ar)
flush(line1_ar)
flush(line2_ar)
flush(line3_ar)

var forecast_line = array.new<line>()
flush(forecast_line)

if barstate.islast and line_bf
    if forecast_result.size() > 0
        value = 0.0
        for i = 1 to forecast_result.size() - 1 by 1
            forecast_line.push(line.new(bar_index + i - 1, forecast_result.get(i - 1), bar_index + i, forecast_result.get(i), color = color.purple, width = 3))


// Plots 
var table data = table.new(position.middle_right, 2, 7, bgcolor = color.blue, frame_color = color.rgb(0, 0, 0), frame_width = 4)
if show_stats
    table.cell(data, 1, 1, text = 'Model Data', bgcolor = color.blue, text_color = color.white)
    table.cell(data, 1, 2, text = 'Correlation: ' + str.tostring(math.round(cor, 2)), bgcolor = color.blue, text_color = color.white)
    table.cell(data, 1, 3, text = 'R2: ' + str.tostring(math.round(r2, 3)), bgcolor = color.blue, text_color = color.white)
    table.cell(data, 1, 4, text = 'Max Forecasted Value: ' + str.tostring(math.round(max_val, 2)), bgcolor = color.blue, text_color = color.white)
    table.cell(data, 1, 5, text = 'Min Forecasted Value: ' + str.tostring(math.round(min_val, 2)), bgcolor = color.blue, text_color = color.white)
    table.cell(data, 1, 6, text = 'Lookback Length: ' + str.tostring(train), bgcolor = color.blue, text_color = color.white)
if barstate.islast and typ == 'Scatter Plot' and not onlytrend
    for idx = 0 to len by 1
        label1_ar.push(f_primary_labels(idx))
        if show_others == 'Show Results and Variances'
            label2_ar.push(f_secondary_labels(idx))
            label3_ar.push(f_secondary_labels2(idx))

if barstate.islast and typ == 'Line Plot' and not onlytrend
    for idx = 0 to len by 1
        line1_ar.push(f_primary_line(idx))
        if show_others == 'Show Results and Variances'
            line2_ar.push(f_secondary_line(idx))
            line3_ar.push(f_secondary_line2(idx))

//-----------------------------------------------------------------------------}


//-----------------------------------------------------------------------------}
// 9- ADAPTIVE TREND FINDER
// * Author      : © Julien_Eche
////////////////////////
atfndr_ok = input.bool(true, title = '═══════════════ Adaptive Trend Finder Settings')


confidence(pearsonR) =>
    switch 
        pearsonR < 0.2 => 'Extremely Weak'
        pearsonR < 0.3 => 'Very Weak'
        pearsonR < 0.4 => 'Weak'
        pearsonR < 0.5 => 'Mostly Weak'
        pearsonR < 0.6 => 'Somewhat Weak'
        pearsonR < 0.7 => 'Moderately Weak'
        pearsonR < 0.8 => 'Moderate'
        pearsonR < 0.9 => 'Moderately Strong'
        pearsonR < 0.92 => 'Mostly Strong'
        pearsonR < 0.94 => 'Strong'
        pearsonR < 0.96 => 'Very Strong'
        pearsonR < 0.98 => 'Exceptionally Strong'
        => 'Ultra Strong'

getTablePosition(string pos) =>
    switch pos
        'Bottom Right' => position.bottom_right
        'Bottom Center' => position.bottom_center
        'Bottom Left' => position.bottom_left
        'Top Right' => position.top_right
        'Top Left' => position.top_left
        'Top Center' => position.top_center
        'Middle Right' => position.middle_right
        => position.middle_left // "Middle Left" - default

// Calculate deviations for given length
calcDev(float source, int length) =>
    float logSource = math.log(source)
    var int period_1 = length - 1
    if barstate.islast
        float sumX = 0.0
        float sumXX = 0.0
        float sumYX = 0.0
        float sumY = 0.0
        for int i = 1 to length by 1
            float lSrc = logSource[i - 1]
            sumX := sumX + i
            sumXX := sumXX + i * i
            sumYX := sumYX + i * lSrc
            sumY := sumY + lSrc
            sumY
        float slope = nz((length * sumYX - sumX * sumY) / (length * sumXX - sumX * sumX))
        float average = sumY / length
        float intercept = average - slope * sumX / length + slope
        float sumDev = 0.0
        float sumDxx = 0.0
        float sumDyy = 0.0
        float sumDyx = 0.0
        float regres = intercept + slope * period_1 * 0.5
        float sumSlp = intercept
        for int i = 0 to period_1 by 1
            float lSrc = logSource[i]
            float dxt = lSrc - average
            float dyt = sumSlp - regres
            lSrc := lSrc - sumSlp
            sumSlp := sumSlp + slope
            sumDxx := sumDxx + dxt * dxt
            sumDyy := sumDyy + dyt * dyt
            sumDyx := sumDyx + dxt * dyt
            sumDev := sumDev + lSrc * lSrc
            sumDev
        float unStdDev = math.sqrt(sumDev / period_1) // unbiased
        float divisor = sumDxx * sumDyy
        float pearsonR = nz(sumDyx / math.sqrt(divisor))
        [unStdDev, pearsonR, slope, intercept]
    else
        [na, na, na, na]

string tlp1 = 'In Long-Term Channel mode, if the channel is not visible, scroll back on the chart for additional historical data. To view both Short-Term and Long-Term channels simultaneously, load this indicator twice on your chart.'
string tlp2 = 'Displays the length of the period automatically selected by the indicator that shows the strongest trend. This period is determined by identifying the highest correlation between price movements and trend direction.'
string tlp3 = 'Pearson\'s R is a statistical measure that evaluates the linear relationship between price movements and trend projection. A value closer to 1 indicates a strong positive correlation, increasing confidence in the trend direction based on historical data.'
string tlp4 = 'Displays the annualized return (CAGR) of the trend over the auto-selected period. This feature is available only for daily (D) and weekly (W) timeframes, providing insight into the expected yearly growth rate if the trend continues.'

sourceInput = input.source(close, title = 'Source')

string group0 = 'CHANNEL SETTINGS'
bool periodMode = input.bool(false, 'Use Long-Term Channel', group = group0, tooltip = tlp1)
float devMultiplier = input.float(2.0, 'Deviation Multiplier:', group = group0, step = 0.1)
color colorInput = input.color(color.gray, '', group = group0, inline = group0)
string lineStyle1 = input.string('Solid', '', group = group0, inline = group0, options = ['Solid', 'Dotted', 'Dashed'])
string extendStyle = input.string('Extend Right', '', group = group0, inline = group0, options = ['Extend Right', 'Extend Both', 'Extend None', 'Extend Left'])
int fillTransparency = input.int(93, 'Fill Transp:', group = group0, inline = 'mid', minval = 0, maxval = 100, step = 1)
int channelTransparency = input.int(40, 'Line Transp:', group = group0, inline = 'mid', minval = 0, maxval = 100, step = 1)

string group1 = 'MIDLINE SETTINGS'
color colorInputMidline = input.color(color.blue, '', group = group1, inline = group1)
int transpInput = input.int(100, 'Transp:', group = group1, inline = group1, minval = 0, maxval = 100, step = 10)
int lineWidth = input.int(1, 'Line Width:', group = group1, inline = group1)
string midLineStyle = input.string('Dashed', '', group = group1, inline = group1, options = ['Dotted', 'Solid', 'Dashed'])

string group2 = 'TABLE SETTINGS'
bool showAutoSelectedPeriod = input(false, 'Show Auto-Selected Period', group = group2, tooltip = tlp2)
bool showTrendStrength = input(false, 'Show Trend Strength', group = group2, inline = 'secondLine')
bool showPearsonInput = input.bool(false, 'Show Pearson\'s R', group = group2, inline = 'secondLine', tooltip = tlp3)
bool showTrendAnnualizedReturn = input(false, 'Show Trend Annualized Return', group = group2, tooltip = tlp4)
string tablePositionInput = input.string('Bottom Center', 'Table Position', options = ['Bottom Right', 'Bottom Left', 'Middle Right', 'Middle Left', 'Top Right', 'Top Left', 'Top Center', 'Bottom Center'], group = group2, inline = 'fourthLine')
string textSizeInput = input.string('Normal', 'Text Size', options = ['Normal', 'Large', 'Small'], group = group2, inline = 'fourthLine')

// Helper function to get the multiplier based on timeframe
get_tf_multiplier() =>
    var float multiplier = 1.0
    if syminfo.type == 'crypto'
        if timeframe.isdaily
            multiplier := 365 // ~365 trading days per year
            multiplier
        else if timeframe.isweekly
            multiplier := 52 // 52 weeks per year
            multiplier
        multiplier
    else // Default for stocks and other asset types
        if timeframe.isdaily
            multiplier := 252 // ~252 trading days per year
            multiplier
        else if timeframe.isweekly
            multiplier := 52 // 52 weeks per year
            multiplier
        multiplier

// Helper function to check if the timeframe is daily or weekly
is_valid_timeframe() =>
    timeframe.isdaily or timeframe.isweekly

var string EXTEND_STYLE = switch extendStyle
    'Extend Right' => extend.right
    'Extend Both' => extend.both
    'Extend None' => extend.none
    => extend.left

// Length Inputs
var array<int> Periodss = periodMode ? array.from(na, 300, 350, 400, 450, 500, 550, 600, 650, 700, 750, 800, 850, 900, 950, 1000, 1050, 1100, 1150, 1200) : array.from(na, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200)

// Calculate deviations, correlation, slope, and intercepts for different lengths
[stdDev01, pearsonR01, slope01, intercept01] = calcDev(sourceInput, Periodss.get(1))
[stdDev02, pearsonR02, slope02, intercept02] = calcDev(sourceInput, Periodss.get(2))
[stdDev03, pearsonR03, slope03, intercept03] = calcDev(sourceInput, Periodss.get(3))
[stdDev04, pearsonR04, slope04, intercept04] = calcDev(sourceInput, Periodss.get(4))
[stdDev05, pearsonR05, slope05, intercept05] = calcDev(sourceInput, Periodss.get(5))
[stdDev06, pearsonR06, slope06, intercept06] = calcDev(sourceInput, Periodss.get(6))
[stdDev07, pearsonR07, slope07, intercept07] = calcDev(sourceInput, Periodss.get(7))
[stdDev08, pearsonR08, slope08, intercept08] = calcDev(sourceInput, Periodss.get(8))
[stdDev09, pearsonR09, slope09, intercept09] = calcDev(sourceInput, Periodss.get(9))
[stdDev10, pearsonR10, slope10, intercept10] = calcDev(sourceInput, Periodss.get(10))
[stdDev11, pearsonR11, slope11, intercept11] = calcDev(sourceInput, Periodss.get(11))
[stdDev12, pearsonR12, slope12, intercept12] = calcDev(sourceInput, Periodss.get(12))
[stdDev13, pearsonR13, slope13, intercept13] = calcDev(sourceInput, Periodss.get(13))
[stdDev14, pearsonR14, slope14, intercept14] = calcDev(sourceInput, Periodss.get(14))
[stdDev15, pearsonR15, slope15, intercept15] = calcDev(sourceInput, Periodss.get(15))
[stdDev16, pearsonR16, slope16, intercept16] = calcDev(sourceInput, Periodss.get(16))
[stdDev17, pearsonR17, slope17, intercept17] = calcDev(sourceInput, Periodss.get(17))
[stdDev18, pearsonR18, slope18, intercept18] = calcDev(sourceInput, Periodss.get(18))
[stdDev19, pearsonR19, slope19, intercept19] = calcDev(sourceInput, Periodss.get(19))

if barstate.islast
    // Find the highest Pearson's R
    float highestPearsonR = math.max(pearsonR01, pearsonR02, pearsonR03, pearsonR04, pearsonR05, pearsonR06, pearsonR07, pearsonR08, pearsonR09, pearsonR10, pearsonR11, pearsonR12, pearsonR13, pearsonR14, pearsonR15, pearsonR16, pearsonR17, pearsonR18, pearsonR19)

    // Determine selected length, slope, intercept, and deviations
    int detectedPeriod = na
    float detectedSlope = na
    float detectedIntrcpt = na
    float detectedStdDev = na
    switch highestPearsonR 
        pearsonR01 => 
    	    detectedPeriod := Periodss.get(1)
    	    detectedSlope := slope01
    	    detectedIntrcpt := intercept01
    	    detectedStdDev := stdDev01
    	    detectedStdDev
        pearsonR02 => 
    	    detectedPeriod := Periodss.get(2)
    	    detectedSlope := slope02
    	    detectedIntrcpt := intercept02
    	    detectedStdDev := stdDev02
    	    detectedStdDev
        pearsonR03 => 
    	    detectedPeriod := Periodss.get(3)
    	    detectedSlope := slope03
    	    detectedIntrcpt := intercept03
    	    detectedStdDev := stdDev03
    	    detectedStdDev
        pearsonR04 => 
    	    detectedPeriod := Periodss.get(4)
    	    detectedSlope := slope04
    	    detectedIntrcpt := intercept04
    	    detectedStdDev := stdDev04
    	    detectedStdDev
        pearsonR05 => 
    	    detectedPeriod := Periodss.get(5)
    	    detectedSlope := slope05
    	    detectedIntrcpt := intercept05
    	    detectedStdDev := stdDev05
    	    detectedStdDev
        pearsonR06 => 
    	    detectedPeriod := Periodss.get(6)
    	    detectedSlope := slope06
    	    detectedIntrcpt := intercept06
    	    detectedStdDev := stdDev06
    	    detectedStdDev
        pearsonR07 => 
    	    detectedPeriod := Periodss.get(7)
    	    detectedSlope := slope07
    	    detectedIntrcpt := intercept07
    	    detectedStdDev := stdDev07
    	    detectedStdDev
        pearsonR08 => 
    	    detectedPeriod := Periodss.get(8)
    	    detectedSlope := slope08
    	    detectedIntrcpt := intercept08
    	    detectedStdDev := stdDev08
    	    detectedStdDev
        pearsonR09 => 
    	    detectedPeriod := Periodss.get(9)
    	    detectedSlope := slope09
    	    detectedIntrcpt := intercept09
    	    detectedStdDev := stdDev09
    	    detectedStdDev
        pearsonR10 => 
    	    detectedPeriod := Periodss.get(10)
    	    detectedSlope := slope10
    	    detectedIntrcpt := intercept10
    	    detectedStdDev := stdDev10
    	    detectedStdDev
        pearsonR11 => 
    	    detectedPeriod := Periodss.get(11)
    	    detectedSlope := slope11
    	    detectedIntrcpt := intercept11
    	    detectedStdDev := stdDev11
    	    detectedStdDev
        pearsonR12 => 
    	    detectedPeriod := Periodss.get(12)
    	    detectedSlope := slope12
    	    detectedIntrcpt := intercept12
    	    detectedStdDev := stdDev12
    	    detectedStdDev
        pearsonR13 => 
    	    detectedPeriod := Periodss.get(13)
    	    detectedSlope := slope13
    	    detectedIntrcpt := intercept13
    	    detectedStdDev := stdDev13
    	    detectedStdDev
        pearsonR14 => 
    	    detectedPeriod := Periodss.get(14)
    	    detectedSlope := slope14
    	    detectedIntrcpt := intercept14
    	    detectedStdDev := stdDev14
    	    detectedStdDev
        pearsonR15 => 
    	    detectedPeriod := Periodss.get(15)
    	    detectedSlope := slope15
    	    detectedIntrcpt := intercept15
    	    detectedStdDev := stdDev15
    	    detectedStdDev
        pearsonR16 => 
    	    detectedPeriod := Periodss.get(16)
    	    detectedSlope := slope16
    	    detectedIntrcpt := intercept16
    	    detectedStdDev := stdDev16
    	    detectedStdDev
        pearsonR17 => 
    	    detectedPeriod := Periodss.get(17)
    	    detectedSlope := slope17
    	    detectedIntrcpt := intercept17
    	    detectedStdDev := stdDev17
    	    detectedStdDev
        pearsonR18 => 
    	    detectedPeriod := Periodss.get(18)
    	    detectedSlope := slope18
    	    detectedIntrcpt := intercept18
    	    detectedStdDev := stdDev18
    	    detectedStdDev
        =>  // pearsonR19
    	    detectedPeriod := Periodss.get(19)
    	    detectedSlope := slope19
    	    detectedIntrcpt := intercept19
    	    detectedStdDev := stdDev19
    	    detectedStdDev

    var line upperLine = na
    var linefill upperFill = na
    var line baseLine = na
    var line lowerLine = na
    var linefill lowerFill = na

    // Calculate start and end price based on detected slope and intercept
    float startPrice = math.exp(detectedIntrcpt + detectedSlope * (detectedPeriod - 1))
    float endPrice = math.exp(detectedIntrcpt)

    int startAtBar = bar_index - detectedPeriod + 1
    var color ChannelColor = color.new(colorInput, channelTransparency)

    if na(baseLine)
        baseLine := line.new(startAtBar, startPrice, bar_index, endPrice, width = lineWidth, extend = EXTEND_STYLE, color = color.new(colorInputMidline, transpInput), style = midLineStyle == 'Dotted' ? line.style_dotted : midLineStyle == 'Dashed' ? line.style_dashed : line.style_solid)
        baseLine
    else
        line.set_xy1(baseLine, startAtBar, startPrice)
        line.set_xy2(baseLine, bar_index, endPrice)

    float upperStartPrice = startPrice * math.exp(devMultiplier * detectedStdDev)
    float upperEndPrice = endPrice * math.exp(devMultiplier * detectedStdDev)
    if na(upperLine)
        upperLine := line.new(startAtBar, upperStartPrice, bar_index, upperEndPrice, width = 1, extend = EXTEND_STYLE, color = ChannelColor, style = lineStyle1 == 'Dotted' ? line.style_dotted : lineStyle1 == 'Dashed' ? line.style_dashed : line.style_solid)
        upperLine
    else
        line.set_xy1(upperLine, startAtBar, upperStartPrice)
        line.set_xy2(upperLine, bar_index, upperEndPrice)
        line.set_color(upperLine, colorInput)

    float lowerStartPrice = startPrice / math.exp(devMultiplier * detectedStdDev)
    float lowerEndPrice = endPrice / math.exp(devMultiplier * detectedStdDev)
    if na(lowerLine)
        lowerLine := line.new(startAtBar, lowerStartPrice, bar_index, lowerEndPrice, width = 1, extend = EXTEND_STYLE, color = ChannelColor, style = lineStyle1 == 'Dotted' ? line.style_dotted : lineStyle1 == 'Dashed' ? line.style_dashed : line.style_solid)
        lowerLine
    else
        line.set_xy1(lowerLine, startAtBar, lowerStartPrice)
        line.set_xy2(lowerLine, bar_index, lowerEndPrice)
        line.set_color(lowerLine, colorInput)

    if na(upperFill)
        upperFill := linefill.new(upperLine, baseLine, color = color.new(colorInput, fillTransparency))
        upperFill
    if na(lowerFill)
        lowerFill := linefill.new(baseLine, lowerLine, color = color.new(colorInput, fillTransparency))
        lowerFill

    var table t = na
    if periodMode
        t := table.new(position.bottom_center, 2, 3)
        t
    else
        t := table.new(getTablePosition(tablePositionInput), 2, 3)
        t

    string text1 = periodMode ? 'Auto-Selected Period (Long Term): ' + str.tostring(detectedPeriod) : 'Auto-Selected Period: ' + str.tostring(detectedPeriod)
    var colorInputLight = color.new(colorInput, 0)

    // Display or hide the "Auto-Selected Period" cell
    if showAutoSelectedPeriod
        table.cell(t, 0, 0, text1, text_color = colorInputLight, text_size = textSizeInput == 'Large' ? size.large : textSizeInput == 'Small' ? size.small : size.normal)

    // Display or hide the "Trend Strength" or "Pearson's R" cell
    if showTrendStrength
        if showPearsonInput
            table.cell(t, 0, 1, 'Pearson\'s R: ' + str.tostring(detectedSlope > 0.0 ? -highestPearsonR : highestPearsonR, '#.###'), text_color = colorInput, text_size = textSizeInput == 'Large' ? size.large : textSizeInput == 'Small' ? size.small : size.normal)
        else
            table.cell(t, 0, 1, 'Trend Strength: ' + confidence(highestPearsonR), text_color = colorInput, text_size = textSizeInput == 'Large' ? size.large : textSizeInput == 'Small' ? size.small : size.normal)

    // Calculate CAGR
    float cagr = na
    if not na(detectedPeriod) and bar_index >= detectedPeriod and is_valid_timeframe()
        float num_of_periods = detectedPeriod
        float multiplier = get_tf_multiplier()
        float startClosePrice = close[detectedPeriod - 1]
        cagr := math.pow(close / startClosePrice, multiplier / num_of_periods) - 1
        cagr

    // Display or hide the "Trend Annualized Return" cell
    if showTrendAnnualizedReturn and is_valid_timeframe()
        table.cell(t, 0, 2, 'Trend Annualized Return: ' + (not na(cagr) ? str.tostring(cagr * 100, '#.#') + '%' : 'N/A'), text_color = colorInput, text_size = textSizeInput == 'Large' ? size.large : textSizeInput == 'Small' ? size.small : size.normal)
